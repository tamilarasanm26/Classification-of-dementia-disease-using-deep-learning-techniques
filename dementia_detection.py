# -*- coding: utf-8 -*-
"""Dementia Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ty87lAjLHSKkiBRYXxJh-d-0D4bgQb_m

Installing Libraries
"""

!pip install tensorflow-addons

pip install --upgrade keras

"""Import Libraries"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.image as img
import cv2
import itertools
import pathlib
import warnings
from PIL import Image
from random import randint
warnings.filterwarnings('ignore')
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split
from sklearn.metrics import matthews_corrcoef as MCC
from sklearn.metrics import balanced_accuracy_score as BAS
from sklearn.metrics import classification_report, confusion_matrix
from tensorflow import keras
from keras import layers
import tensorflow as tf
import tensorflow_addons as tfa
from tensorflow.keras.preprocessing import image_dataset_from_directory
from keras.utils import plot_model
from tensorflow.keras import Sequential, Input
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.layers import Conv2D, Flatten
from tensorflow.keras.callbacks import ReduceLROnPlateau
from tensorflow.keras.applications.inception_v3 import InceptionV3
from tensorflow.keras.preprocessing.image import ImageDataGenerator as IDG
from tensorflow.keras.layers import SeparableConv2D, BatchNormalization, GlobalAveragePooling2D
from distutils.dir_util import copy_tree, remove_tree
import os
print(os.listdir("/content/drive/MyDrive/New mri/Dataset"))
print("TensorFlow Version:", tf.__version__)

"""Split folders"""

!pip install split-folders
import splitfolders
splitfolders.ratio('/content/drive/MyDrive/New mri/Dataset', output="output", seed=1345, ratio=(.8, 0.1,0.1))

"""Train,Validation and Test"""

IMG_HEIGHT = 128
IMG_WIDTH = 128
train_ds = tf.keras.preprocessing.image_dataset_from_directory(
"./output/train",
seed=123,
image_size=(IMG_HEIGHT, IMG_WIDTH),
batch_size=64
)

test_ds = tf.keras.preprocessing.image_dataset_from_directory(
"./output/test",
seed=123,
image_size=(IMG_HEIGHT, IMG_WIDTH),
batch_size=64
)

val_ds = tf.keras.preprocessing.image_dataset_from_directory(
"./output/val",
seed=123,
image_size=(IMG_HEIGHT, IMG_WIDTH),
batch_size=64
)

def get_number_of_images(folder_path):
  number_of_images = 0
  for file in os.listdir(folder_path):
    if file.endswith(".png") or file.endswith(".jpg"):
      number_of_images += 1
  return number_of_images
if __name__ == "__main__":
  number_1= get_number_of_images("/content/drive/MyDrive/New mri/Dataset/Mild_Demented")
  print("Number of images in Mild_Demented:", number_1)
  number_2 = get_number_of_images("/content/drive/MyDrive/New mri/Dataset/Moderate_Demented")
  print("Number of images in Moderate_Demented:", number_2)
  number_3 = get_number_of_images("/content/drive/MyDrive/New mri/Dataset/Non_Demented")
  print("Number of images in Non_Demented:", number_3)
  number_4= get_number_of_images("/content/drive/MyDrive/New mri/Dataset/Seizure MRI")
  print("Number of images in Seizure MRI:", number_4)
  number_5 = get_number_of_images("/content/drive/MyDrive/New mri/Dataset/Very_Mild_Demented")
  print("Number of images in Very_Mild_Demented:", number_5)
  number_6 = get_number_of_images("/content/drive/MyDrive/New mri/Dataset/parkinson")
  print("Number of images in Parkinson:", number_6)
  number_of_images_list = [number_1, number_2, number_3,number_4,number_5,number_6]
  colors = ['red', 'green', 'blue','yellow','pink','purple']
  plt.bar(['Mild', 'Moderate', 'Non','Seizure','Very_Mi','parkinson'], number_of_images_list, color=colors)
  plt.title('Number of Mild_Demented, Moderate_Demented, Non_Demented,Seizure MRI,Very_Mild_Demented,parkinson')
  plt.xlabel('Type of image')
  plt.ylabel('Number of images')
  plt.show()

class_names = train_ds.class_names
print(class_names)
train_ds

img_augmentation = keras.Sequential(
    [
        layers.RandomRotation(factor=0.15),
        layers.RandomTranslation(height_factor=0.1, width_factor=0.1),
        layers.RandomFlip(),
        layers.RandomContrast(factor=0.1),
    ],
    name="img_augmentation",
)

plt.figure(figsize=(10, 10))
for images, label in train_ds.take(1):
    for i in range(9):
        augmented_images = img_augmentation(images)
        ax = plt.subplot(3, 3, i + 1)
        plt.imshow(augmented_images[0].numpy().astype("uint8"))
        plt.axis("off")

def get_number_of_images(folder_path):
  number_of_images = 0
  for file in os.listdir(folder_path):
    if file.endswith(".png") or file.endswith(".jpg"):
      number_of_images += 1
  return number_of_images
if __name__ == "__main__":
  number_1= get_number_of_images("/content/drive/MyDrive/New mri/Dataset/Mild_Demented")
  print("Number of images in Mild_Demented:", number_1)
  number_2 = get_number_of_images("/content/drive/MyDrive/New mri/Dataset/Moderate_Demented")
  print("Number of images in Moderate_Demented:", number_2)
  number_3 = get_number_of_images("/content/drive/MyDrive/New mri/Dataset/Non_Demented")
  print("Number of images in Non_Demented:", number_3)
  number_4= get_number_of_images("/content/drive/MyDrive/New mri/Dataset/Seizure MRI")
  print("Number of images in Seizure MRI:", number_4)
  number_5 = get_number_of_images("/content/drive/MyDrive/New mri/Dataset/Very_Mild_Demented")
  print("Number of images in Very_Mild_Demented:", number_5)
  number_6 = get_number_of_images("/content/drive/MyDrive/New mri/Dataset/parkinson")
  print("Number of images in Parkinson:", number_6)
  number_of_images_list = [number_1, number_2, number_3,number_4,number_5,number_6]
  colors = ['red', 'green', 'blue','yellow','pink','purple']
  plt.bar(['Mild', 'Moderate', 'Non','Seizure','Very_Mi','parkinson'], number_of_images_list, color=colors)
  plt.title('Number of Mild_Demented, Moderate_Demented, Non_Demented,Seizure MRI,Very_Mild_Demented,parkinson')
  plt.xlabel('Type of image')
  plt.ylabel('Number of images')
  plt.show()

plt.figure(figsize=(10, 10))
for images, labels in train_ds.take(1):
    for i in range(9):
        ax = plt.subplot(3, 3, i + 1)
        plt.imshow(images[i].numpy().astype("uint8"))
        plt.title(class_names[labels[i]])
        plt.axis("off")

# fig = plt.figure()
# ax = fig.add_axes([0,0,1,1])
# size = [896,64,3200,2240]
# ax.bar(class_names,size)
# plt.show

"""Simple CNN"""

model = keras.models.Sequential()
model.add(keras.layers.experimental.preprocessing.Rescaling(1./255, input_shape=(IMG_HEIGHT,IMG_WIDTH, 3)))
model.add(keras.layers.Conv2D(filters=16,kernel_size=(3,3),padding='same',activation='relu',kernel_initializer="he_normal"))
model.add(keras.layers.MaxPooling2D(pool_size=(2,2)))


model.add(keras.layers.Conv2D(filters=32,kernel_size=(3,3),padding='same',activation='relu',kernel_initializer="he_normal"))
model.add(keras.layers.MaxPooling2D(pool_size=(2,2)))

model.add(keras.layers.Dropout(0.20))

model.add(keras.layers.Conv2D(filters=64,kernel_size=(3,3),padding='same',activation='relu',kernel_initializer="he_normal"))
model.add(keras.layers.MaxPooling2D(pool_size=(2,2)))

model.add(keras.layers.Dropout(0.25))
model.add(keras.layers.Flatten())
model.add(keras.layers.Dense(128,activation="relu",kernel_initializer="he_normal"))
model.add(keras.layers.Dense(64,"relu"))
model.add(keras.layers.Dense(6,"softmax"))

model.compile(loss="sparse_categorical_crossentropy",
              optimizer = "Adam",metrics=["accuracy"])

model.summary()

hist = model.fit(train_ds,validation_data=val_ds,epochs=30, batch_size=64, verbose=1)

get_ac = hist.history['accuracy']
get_los = hist.history['loss']
val_acc = hist.history['val_accuracy']
val_loss = hist.history['val_loss']

import matplotlib.pyplot as plt

epochs = range(len(get_ac))

# Plot accuracy and loss of training data
plt.plot(epochs, get_ac, 'g', label='Accuracy of Training Data')
plt.plot(epochs, get_los, 'r', label='Loss of Training Data')
plt.title('Training Data Accuracy and Loss')
plt.legend(loc=0)

# Set x-axis and y-axis labels
plt.xlabel('Epochs')
plt.ylabel('Accuracy/Loss')

plt.show()

# Create a new figure for the next plot
plt.figure()

# Plot training accuracy and validation accuracy
plt.plot(epochs, get_ac, 'g', label='Accuracy of Training Data')
plt.plot(epochs, val_acc, 'r', label='Accuracy of Validation Data')
plt.title('Training and Validation Accuracy')
plt.legend(loc=0)

# Set x-axis and y-axis labels
plt.xlabel('Epochs')
plt.ylabel('Accuracy')

plt.show()

# Create a new figure for the next plot
plt.figure()

# Plot training loss and validation loss
plt.plot(epochs, get_los, 'g', label='Loss of Training Data')
plt.plot(epochs, val_loss, 'r', label='Loss of Validation Data')
plt.title('Training and Validation Loss')
plt.legend(loc=0)

# Set x-axis and y-axis labels
plt.xlabel('Epochs')
plt.ylabel('Loss')

plt.show()

loss, accuracy = model.evaluate(test_ds)
print(loss,accuracy)

!pip install matplotlib

plt.subplots(figsize=(20, 20))
for images, labels in test_ds.take(1):
    for i in range(16):
        ax = plt.subplot(4, 4, i + 1)
        plt.imshow(images[i].numpy().astype("uint8"))
        predictions = model.predict(tf.expand_dims(images[i], 0))
        score = tf.nn.softmax(predictions[0])
        if(class_names[labels[i]]==class_names[np.argmax(score)]):
            plt.title("Actual: "+class_names[labels[i]])
            plt.ylabel("Predicted: "+class_names[np.argmax(score)],fontdict={'color':'green'})

        else:
            plt.title("Actual: "+class_names[labels[i]])
            plt.ylabel("Predicted: "+class_names[np.argmax(score)],fontdict={'color':'red'})
        plt.gca().axes.yaxis.set_ticklabels([])
        plt.gca().axes.xaxis.set_ticklabels([])

for img, label in test_ds.take(1):
    print(label, len(label))
    break

from sklearn.metrics import classification_report,confusion_matrix
actual_label = []
pred_label = []
for img, label in test_ds.take(1):
    pred = model.predict(img)
    pred = np.argmax(pred, axis=1)
    print(classification_report(label,pred))

from sklearn.metrics import classification_report

# Your existing code to get the classification report
for img, label in test_ds.take(1):
    pred = model.predict(img)
    pred = np.argmax(pred, axis=1)
    report = classification_report(label, pred, output_dict=True)

# Specify the class index for which you want to store the F1-score
class_index = 0  # Change this to the desired class index

# Extract and store the F1-score for the specified class
f1_score = report[str(class_index)]['f1-score']

# Now, you have the F1-score for the specified class in the 'f1_score' variable
print(f'F1-score for class {class_index}: {f1_score}')

"""DNN

"""

model = keras.models.Sequential()
model.add(keras.layers.experimental.preprocessing.Rescaling(1./255, input_shape=(IMG_HEIGHT,IMG_WIDTH, 3)))
# Replace convolutional layers with feedforward neural network layers
model.add(keras.layers.Flatten())
model.add(keras.layers.Dense(128, activation="relu", kernel_initializer="he_normal"))
model.add(keras.layers.Dense(64, activation="relu", kernel_initializer="he_normal"))
model.add(keras.layers.Dense(6, "softmax"))

model.compile(loss="sparse_categorical_crossentropy",
              optimizer = "adam",metrics=["accuracy"])

model.summary()

hist = model.fit(train_ds,validation_data=val_ds,epochs=30, batch_size=64, verbose=1)

get_ac3 = hist.history['accuracy']
get_los3 = hist.history['loss']
val_acc3 = hist.history['val_accuracy']
val_loss3 = hist.history['val_loss']

epochs = range(len(get_ac3))
plt.plot(epochs, get_ac3, 'g', label='Accuracy of Training data')
plt.plot(epochs, get_los3, 'r', label='Loss of Training data')
plt.title('Training data accuracy and loss')
plt.legend(loc=0)
plt.figure()

plt.plot(epochs, get_ac3, 'g', label='Accuracy of Training Data')
plt.plot(epochs, val_acc3, 'r', label='Accuracy of Validation Data')
plt.title('Training and Validation Accuracy')
plt.legend(loc=0)
plt.figure()

plt.plot(epochs, get_los3, 'g', label='Loss of Training Data')
plt.plot(epochs, val_loss3, 'r', label='Loss of Validation Data')
plt.title('Training and Validation Loss')
plt.legend(loc=0)
plt.figure()
plt.show()

loss5, accuracy2 = model.evaluate(test_ds)
print(loss5,accuracy2)

plt.subplots(figsize=(20, 20))
for images, labels in test_ds.take(1):
    for i in range(16):
        ax = plt.subplot(4, 4, i + 1)
        plt.imshow(images[i].numpy().astype("uint8"))
        predictions = model.predict(tf.expand_dims(images[i], 0))
        score = tf.nn.softmax(predictions[0])
        if(class_names[labels[i]]==class_names[np.argmax(score)]):
            plt.title("Actual: "+class_names[labels[i]])
            plt.ylabel("Predicted: "+class_names[np.argmax(score)],fontdict={'color':'green'})

        else:
            plt.title("Actual: "+class_names[labels[i]])
            plt.ylabel("Predicted: "+class_names[np.argmax(score)],fontdict={'color':'red'})
        plt.gca().axes.yaxis.set_ticklabels([])
        plt.gca().axes.xaxis.set_ticklabels([])

for img, label in test_ds.take(1):
    print(label, len(label))
    break

actual_label = []
pred_label = []
for img, label in test_ds.take(1):
    pred = model.predict(img)
    pred = np.argmax(pred, axis=1)
    print(classification_report(label,pred))



"""RESNET-50"""

model = keras.models.Sequential()
model.add(keras.layers.experimental.preprocessing.Rescaling(1./255, input_shape=(IMG_HEIGHT, IMG_WIDTH, 3)))
model.add(keras.applications.ResNet50(include_top=False, input_shape=(IMG_HEIGHT, IMG_WIDTH, 3)))
model.add(keras.layers.GlobalAveragePooling2D())
model.add(keras.layers.Dense(128, activation="relu", kernel_initializer="he_normal"))
model.add(keras.layers.Dense(64, "relu"))
model.add(keras.layers.Dense(6, "softmax"))

model.compile(loss="sparse_categorical_crossentropy",
              optimizer = "adam",metrics=["accuracy"])

model.summary()

hist = model.fit(train_ds,validation_data=val_ds,epochs=30, batch_size=64, verbose=1)

get_ac3 = hist.history['accuracy']
get_los3 = hist.history['loss']
val_acc3 = hist.history['val_accuracy']
val_loss3 = hist.history['val_loss']

epochs = range(len(get_ac3))
plt.plot(epochs, get_ac3, 'g', label='Accuracy of Training data')
plt.plot(epochs, get_los3, 'r', label='Loss of Training data')
plt.title('Training data accuracy and loss')
plt.legend(loc=0)
plt.figure()

plt.plot(epochs, get_ac3, 'g', label='Accuracy of Training Data')
plt.plot(epochs, val_acc3, 'r', label='Accuracy of Validation Data')
plt.title('Training and Validation Accuracy')
plt.legend(loc=0)
plt.figure()

plt.plot(epochs, get_los3, 'g', label='Loss of Training Data')
plt.plot(epochs, val_loss3, 'r', label='Loss of Validation Data')
plt.title('Training and Validation Loss')
plt.legend(loc=0)
plt.figure()
plt.show()

loss3, accuracy3 = model.evaluate(test_ds)
print(loss3,accuracy3)

plt.subplots(figsize=(20, 20))
for images, labels in test_ds.take(1):
    for i in range(16):
        ax = plt.subplot(4, 4, i + 1)
        plt.imshow(images[i].numpy().astype("uint8"))
        predictions = model.predict(tf.expand_dims(images[i], 0))
        score = tf.nn.softmax(predictions[0])
        if(class_names[labels[i]]==class_names[np.argmax(score)]):
            plt.title("Actual: "+class_names[labels[i]])
            plt.ylabel("Predicted: "+class_names[np.argmax(score)],fontdict={'color':'green'})

        else:
            plt.title("Actual: "+class_names[labels[i]])
            plt.ylabel("Predicted: "+class_names[np.argmax(score)],fontdict={'color':'red'})
        plt.gca().axes.yaxis.set_ticklabels([])
        plt.gca().axes.xaxis.set_ticklabels([])

for img, label in test_ds.take(1):
    print(label, len(label))
    break

actual_label = []
pred_label = []
for img, label in test_ds.take(1):
    pred = model.predict(img)
    pred = np.argmax(pred, axis=1)
    print(classification_report(label,pred))

"""DENSENET-169"""

model = keras.models.Sequential()
model.add(keras.layers.experimental.preprocessing.Rescaling(1./255, input_shape=(IMG_HEIGHT, IMG_WIDTH, 3)))
model.add(keras.applications.DenseNet169(include_top=False, input_shape=(IMG_HEIGHT, IMG_WIDTH, 3)))
model.add(keras.layers.GlobalAveragePooling2D())
model.add(keras.layers.Dense(128, activation="relu", kernel_initializer="he_normal"))
model.add(keras.layers.Dense(64, "relu"))
model.add(keras.layers.Dense(6, "softmax"))

model.compile(loss="sparse_categorical_crossentropy",
              optimizer = "adam",metrics=["accuracy"])

model.summary()

hist = model.fit(train_ds,validation_data=val_ds,epochs=30, batch_size=64, verbose=1)

get_ac5 = hist.history['accuracy']
get_los5 = hist.history['loss']
val_acc5 = hist.history['val_accuracy']
val_loss5 = hist.history['val_loss']

epochs = range(len(get_ac5))
plt.plot(epochs, get_ac5, 'g', label='Accuracy of Training data')
plt.plot(epochs, get_los5, 'r', label='Loss of Training data')
plt.title('Training data accuracy and loss')
plt.legend(loc=0)
plt.figure()

plt.plot(epochs, get_ac5, 'g', label='Accuracy of Training Data')
plt.plot(epochs, val_acc5, 'r', label='Accuracy of Validation Data')
plt.title('Training and Validation Accuracy')
plt.legend(loc=0)
plt.figure()

plt.plot(epochs, get_los5, 'g', label='Loss of Training Data')
plt.plot(epochs, val_loss5, 'r', label='Loss of Validation Data')
plt.title('Training and Validation Loss')
plt.legend(loc=0)
plt.figure()
plt.show()

loss5, accuracy4 = model.evaluate(test_ds)
print(loss5,accuracy4)

plt.subplots(figsize=(20, 20))
for images, labels in test_ds.take(1):
    for i in range(16):
        ax = plt.subplot(4, 4, i + 1)
        plt.imshow(images[i].numpy().astype("uint8"))
        predictions = model.predict(tf.expand_dims(images[i], 0))
        score = tf.nn.softmax(predictions[0])
        if(class_names[labels[i]]==class_names[np.argmax(score)]):
            plt.title("Actual: "+class_names[labels[i]])
            plt.ylabel("Predicted: "+class_names[np.argmax(score)],fontdict={'color':'green'})

        else:
            plt.title("Actual: "+class_names[labels[i]])
            plt.ylabel("Predicted: "+class_names[np.argmax(score)],fontdict={'color':'red'})
        plt.gca().axes.yaxis.set_ticklabels([])
        plt.gca().axes.xaxis.set_ticklabels([])

for img, label in test_ds.take(1):
    print(label, len(label))
    break

actual_label = []
pred_label = []
for img, label in test_ds.take(1):
    pred = model.predict(img)
    pred = np.argmax(pred, axis=1)
    print(classification_report(label,pred))

accuracy_values = [0.98, 0.69, 0.94,0.86]
colors = ['red', 'green' ,'violet','orange']

# Create a bar chart
bar_chart = plt.bar(['CNN','DNN','RESNET-50','DESNET-169'], accuracy_values, color=colors)

# Add accuracy values above the bars
for bar in bar_chart:
    y = bar.get_height()
    plt.text(bar.get_x() + 0.25, y + 0.01, f'{y:.2f}', ha='center', va='bottom')

# Set labels and title
plt.xlabel('Models')
plt.ylabel('Accuracy')
plt.title('Accuracy of 5 Models')

# Show the plot
plt.show()

